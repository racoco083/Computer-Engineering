# Application Layer

**:book: Contents**
* [소켓의 이해](#1장 소켓의 이해)

# 1장 소켓의 이해

## 1-1 소켓의 정의
소켓은 자신이 속한 응용 프로그램에서 파일도 포함해서 유일하게 구분되어야 하기에 자기만의 번호가 있으며, TCP를 사용할지 UDP를 사용할지를 정해준다.

소켓주소(sockaddr) : ip와 port 번호가 저장되어 있다.

## 1-2 소켓번호
파일기술자는 기술자 테이블(descriptor table)의 index 번호인데(그림 2-2 참조), 기술자 테이블이란 현재 open되어 있는 파일의 각종 정보를 포함하고 있는 구조체를 가리키는 포인터들로 구성된 테이블이다.

예를들어 한 응용 프로그램내에서 2개의 파일을 open하면 파일기술자는 3과 4가 배정된다

![image](https://user-images.githubusercontent.com/21019088/54738469-c96ed500-4bf7-11e9-9a03-288f12089b51.png)

프로그램에서 소켓을 개설하면 파일기술자와 똑같은 기능을 하는 소켓기술자(socket descriptor)가 리턴된다.

응용 프로그램에서 이 소켓을 통하여 목적지 호스트와 연결을 요구하거나 패킷을 송수신할 때 해당 소켓기술자를 사용하게 된다(이 책에서는 편의상 소켓기술자를 소켓번호라고 부르겠다).

UNIX에서는 파일기술자와 소켓기술자가 같은 기술자 테이블의 index가 된다. 즉, 파일과 소켓이 기술자 테이블을 공유한다.

한 프로세스에서 파일 open시 리턴되는 파일기술자와 소켓 개설시 리턴되는 소켓기술자의 값은 서로 중복된 것이 없게 된다.

그림 2-2에는 두 개의 파일과 한 개의 소켓을 개설하였을 때의 기술자 테이블과 기술자 테이블이 가리키는 파일 또는 소켓 데이터 구조체를 나타내고 있다.

그림 2-3에 응용 프로그램과 소켓 그리고 TCP/IP의 관계를 구체적으로 나타냈다.

네 개의 응용 프로그램이 소켓번호로 각각 4, 3, 3, 3을 사용하고 있는 것을 나타냈다(응용 프로그램 1은 파일을 하나 먼저 열고 있으므로 소켓번호가 4가 된 것이다).

한편 소켓번호는 응용 프로그램내에서 순서대로 배정되며 그 프로그램내에서만 유일하게 구분되면 되는 것이므로 서로 다른 응용 프로그램에서 같은 소켓번호를 사용하는 것은 문제가 되지 않는다.

포트번호는 TCP/IP가 지원하는 상위 계층의 프로세스를 구분하기 위한 번호이므로 하나의 컴퓨터내에 있는 응용 프로세스들은 반드시 서로 다른 포트번호를 사용하여야 한다.

그림 2-3에서는 네 개의 응용 프로그램이 3000번부터 3003번의 포트번호를 사용하는 것을 가정하였다.

그림 2-3에서 연결형 서비스는 TCP가 그리고 비연결형 서비스는 UDP가 각각 처리하는 것을 보였다.

![image](https://user-images.githubusercontent.com/21019088/54738414-8ca2de00-4bf7-11e9-8d5e-8b6d507572ac.png)

bind : 매개변수로 소켓과 소켓 주소를 사용하며 주로 서버에서 사용된다. 필요한 이유는 임의의 클라이언트가 서버의 특정 프로그램이 만든 소켓과 통신을 하려면 그 소켓을 찾을 수 있어야 하기 때문이다. 서버에서는 HTTP, FTP와 같은 프로토콜은 유일한 포트를 갖는다. bind를 하면 해당 소켓번호를 인덱스로 하는 기술자 테이블에 자신의 local ip와 local port를 저장한다.

클라이언트에서 bind를 호출할 필요가 없는 이유는, 클라이언트는 포트번호를 임의로 사용해도 되기 때문이다. 클라이언트는 오히려 bind를 사용하는 것이 클라이언트 프로그램의 범용성을 떨어뜨리게 된다. 왜냐하면 같은 포트번호를 사용하는 클라이언트 프로그램들이 하나의 컴퓨터에서 두 개 이상 실행되면 에러가 발생하기 때문이다. 그래서 서버1과 클라이언트 2,3이 HTTP통신을 한다고 하면 서버는 80번 포트를 고정으로 사용해야 하지만 클라이언트 2,3은 10000번이든 12000번이든 아무거나 골라서 사용해도 된다.

## 1-3 소켓의 이용 
소켓을 이용한 네트웍 응용 프로그램에서 상대방과 패킷을 주고받기 위하여는 다음의 다섯 가지 정보가 정해져야 한다.
1. 통신에 사용할 프로토콜(TCP 또는 UDP)
2. 자신의 ip주소
3. 자신의 포트번호
4. 상대방의 ip주소
5. 상대방의 포트번호

## P.S 
하나의 클라이언트와 서버가 HTTP통신을 한다면 서버는 해당 응용 프로그램에 여러개의 소켓이 있을 수 있다. (한 컴퓨터에서 웹브라우저 하나가 웹툰 신의탑 보고 있으면, 또 다른 웹 브라우저는 다른 웹툰 보고 있는 경우)

# 2장 인터넷 주소변환
바이트 주소 변환이 필요한 이유 : 인터넷에는 여러 가지 종류의 컴퓨터들이 접속되어 있고 os, cpu 등에 따라 컴퓨터 내부에서 표현하는 방식이 다르가. 따라서 데이터를 다른 컴퓨터로 그대로 전송하면 문제가 발생할 수 있다.이러한 통신상의 문제를 피하기 위해 데이터를 전송하기 전에 그리고 데이터를 수신한 우에 바이트 순서를 맞추는 절차가 필요하다.

## 2-1 바이트 순서

바이트 순서 : 바이트 순서에는 호스트 바이트 순서와 네트웍 바이트 순서 두 가지가 있다.

호스트 바이트 순서는 컴퓨터가 내부 메모리에 숫자를 저장하는 순서를 말하는데, 이것은 컴퓨터의 cpu의 종류에 따라 다르다. 80x86계열의 cpu가 사용하는 호스트 바이트 순서는 예를들어 두 바이트로 구성된 0xC3E2가 있으면 E2, C3의 순서로 하위 바이트부터 메모리에 저장되고 MC68000 계열의 cpu에서는 C3, E2의 순서로 상위 바이트부터 메모리에 저장된다.(둘 다 낮은 주소의 메모리부터 큰 메모리 주소로 채워나간다.)

![image](https://user-images.githubusercontent.com/21019088/54738760-e1932400-4bf8-11e9-8918-7a32d1d05848.png)

네트웍 바이트 순서는 네트웍에서 바이트 단위로 데이터가 전달되는 순서를 말하는데 2바이트의 수 0xC3E2의 경우 C3, E2의 순서로 즉, 상위 바이트 부터 전송된다. 즉, 80x86계열의 cpu가 사용하는 호스트 바이트 순서는 네트웍 바이트 순서와 다르다. 따라서 80x86계열의 컴퓨터에서 네트웍을 통하여 전송한 데이터를 MC68000계열의 컴퓨터가 수신하면 바이트 순서가 바뀌게 된다.

이러한 문제를 해결하기 위해 컴퓨터 내부에서 만들어진 호스트 바이트 순서의 데이터를 네트웍으로 전송하기 전에 htons()(host-to-network)함수를 사용하여 모두 네트웍 바이트 순서로 바꾸어야 한다.

반대로 네트웍에서 수신한 데이터는 ntohs()(network-to-host) 함수를 사용하여 자신에게 맞는 호스트 바이트 순서로 항상 바꾸어야 한다. 즉, 네트웍 바이트 순서를 지켜 데이터를 전송함으로써 수신한 데이터가 어떤 종류의 컴퓨터에서 만들어진 것인지 알 필요가 없도록 하는 것이다.

위에서 MC68000 계열의 CPU에서는 호스트 바이트 순서와 네트웍 바이트 순서가 같은 것을 알 수 있는데 이러한 호스트에서의 htons()와 ntohs() 함수는 아무 일도 하지 않게 된다.

## 2-2 ip 주소변환
32비트의 IP 주소를 편의에 따라 cc.kangwon.ac.kr과 같은 도메인 네임, 그리고192.203.144.11과 같은 dotted decimal 표시법 등으로 바꾸어 널리 사용하고 있다.

한편 IP 패킷을 네트웍으로 실제로 전송할 때에는 32비트의 (binary) IP 주소가 필요하다.

예를들어 그림 2-6에서 dotted decimal로 표현된 192. 203.144.11을 32비트의 IP 주소로 변환하려면 inet_addr() 시스템 콜을 사용하고 IP 주소를 다시 dotted decimal로 변환하려면 inet_ntoa()를 사용한다.

![image](https://user-images.githubusercontent.com/21019088/54738806-08e9f100-4bf9-11e9-85fa-71f116b5835c.png)

# 3장 클라이언트 프로그램 작성 절차

## 3-1 연결형(TCP) 클라이언트 프로그램 작성 절차
연결형 서비스를 이용하기 위하여 connect()를 호출하여 서버와 연결을 요청하고 연결이 이루어지면 send()와 recv()를 사용하여 데이터를 송수신하고 작업이 종료되면 close()로 소켓을 닫는다.

![image](https://user-images.githubusercontent.com/21019088/54738843-3171eb00-4bf9-11e9-8fde-bbcf663c08e0.png)

### 3-1-1 socket(), 소켓 개설
socket()을 호출시에는 트랜스포트 프로토콜만을 지정하게 되는데 그림 2-8에 socket() 수행시 내부적으로 일어나는 동작을 나타냈다. 여기서 응용 프로그램이 프로토콜을 지정하여 socket()을 호출하면 소켓 인터페이스가 새로 생성된 소켓의 소켓번호를 리턴하는 것을 보여주고 있다.

한편 클라이언트는 자신이 사용할 포트번호를 명시적으로 지정할 필요가 없다. 즉, 클라이언트는 bind()를 호출할 필요가 없이 다음에 설명할 connect() 호출시 시스템(TCP/IP)이 임의의 포트번호를 지정해 준다.

![image](https://user-images.githubusercontent.com/21019088/54738852-40f13400-4bf9-11e9-8376-a5c3e516cf35.png)

### 3-1-2 연결할 서버의 소켓주소 구조체(sockaddr_in) 작성
클라이언트는 connect()를 호출하기 전에 연결하고자 하는 서버의 주소를 지정한다. 4바이트의 IP 주소와 2바이트의 포트번호를 포함하는 소켓주소 구조체 sockadr_in를 작성하여야 한다.

### 3-1-3 connect(), 서버와 연결요청
(2)에서 만든 서버의 소켓주소 구조체를 사용하여 서버에게 접속요청을 하기 위하여 connect()를 호출한다. connect()는 상대방 즉, 서버의 IP 주소와 포트번호를 명시하여 3-1-1에서 구한 소켓번호로 호출하면 된다. 클라이언트가 호출한 connect()가 성공적으로 연결되려면 서버에서 accept()를 호출해 두고 있어야 한다.

connect()의 사용 문법은 아래와 같다.

![image](https://user-images.githubusercontent.com/21019088/54738888-69792e00-4bf9-11e9-8aa8-fb6dc85080e5.png)

![image](https://user-images.githubusercontent.com/21019088/54738909-79910d80-4bf9-11e9-8436-b0f76cd39b8e.png)

### 3-1-4 send(), recv(), 데이터 송수신
클라이언트가 서버와 연결되면 send(), recv() 또는 write(), read()를 사용하여 서버와 데이터를 송수신할 수 있다.

![image](https://user-images.githubusercontent.com/21019088/54738924-89a8ed00-4bf9-11e9-916d-4af797fedd27.png)

### 3-1-5 close(), 소켓 닫기
소켓의 사용을 소켓의 사용을 마치려면 해당 소켓번호(s)를 지정하여 close(s)를 호출하여 소켓을 종료하여야 한다.

close()를 호출한 시점에 서버나 클라이언트의 송신 버퍼에 있으나 아직 전송하지 못한, 또는 네트웍내에서 전달중인 패킷들이 있을 수 있는데 close()는 디폴트로 이러한 패킷들을 모두 처리한 후에 소켓을 닫게 되어 있다. => 4 hands shake 참고

## 3-2 비연결형(UDP) 클라이언트 프로그램 작성 절차
비연결형 서비스이므로 connect() 시스템 호출이 필요 없고 클라이언트와 서버는 소켓 개설 후 바로 데이터를 송수신할 수 있다.

![image](https://user-images.githubusercontent.com/21019088/54738969-bbba4f00-4bf9-11e9-959d-7b29711d4348.png)

한편 비연결형 통신에서는 연결형 소켓 프로그래밍과 달리, 소켓이 목적지별 로 개설되어 있는 것이 아니므로 하나의 소켓을 통하여 임의의 목적지를 향하여 IP 패킷을 보낼 수 있는데 이것이 바로 UDP를 사용하는 최대의 장점이기도 하다.( = 소켓이 고정되어 있지 않다.) 그러나 비연결형으로 만든 소켓으로 패킷을 전송할 때에는 각 패킷 전송시마다 목적지의 IP 주소와 포트번호(즉 소켓주소)를 항상 함수 인자로 주어야 한다.

비연결형 소켓에서 사용하는 데이터 송수신 함수인 sendto()와 recvfrom()의 사용법을 정리하였다.

![image](https://user-images.githubusercontent.com/21019088/54739000-ce348880-4bf9-11e9-8416-48674c1bf857.png)

# 4장 서버 프로그램 작성 절차

## 4-1 연결형 서버 프로그램 작성 절차
밑의 그림에 TCP(연결형) 서버를 iterative 형태 즉, 서비스 요구가 들어오는 순서대로 처리해 주는 형태로 구축하는 절차를 나타냈다.
서버는 socket()으로 소켓을 개설하고 bind()를 수행한 후 listen()으로 소켓을 수동 대기모드로 만든다.

다음에는 accept()를 호출하여 자신에게 연결을 요청하는 클라이언트의 연결을 처리하도록 한다.

클라이언트와 연결된 후에는 클라이언트가 요구하는 요청(request)을 처리하고 결과(response)를 전송해 주는 방식으로 서비스를 처리하고 하나의 서비스를 완료하면 다음 요청을 처리한다.

![image](https://user-images.githubusercontent.com/21019088/54739056-020fae00-4bfa-11e9-8056-98aed57ff661.png)

### 4-1-1 socket(), 소켓의 생성
서버 프로그램도 클라이언트와 마찬가지로 통신을 하기 위하여는 트랜스포트 프로토콜을 지정하여 소켓을 만들어야 하는데 이를 위해 socket() 함수를 사용한다. socket()의 사용 방법은 클라이언트의 경우와 같다.

### 4-1-2 bind(), 소켓번호와 소켓주소 구조체 연결
socket() 시스템 콜을 통해서 생성된 소켓은 그 응용 프로그램내에서 유일한 번호인 소켓번호를 하나 배정받는다.

그러나 이 번호는 응용 프로그램만 알고 사용하는 번호이므로 이 프로그램이 컴퓨터 외부와 통신하려면 이 소켓번호와 TCP/IP 시스템이 제공하는 소켓주소(IP 주소 + 포트번호)를 연결해 두어야 하며 이를 위하여 bind()를 사용한다.

bind()의 사용 문법은 아래와 같다.

![image](https://user-images.githubusercontent.com/21019088/54739120-3f743b80-4bfa-11e9-97de-d51a7f1630c4.png)

밑의 그림은 bind() 호출시의 IP 주소, 포트번호, 그리고 소켓번호의 관계를 나타냈다.

bind()는 응용 프로그램 자신의(local) 주소와 소켓번호를 연결하는 작업이라고 할 수 있다.

서버에서 bind()가 반드시 필요한 이유는 임의의 클라이언트가 서버의 특정 프로그램이 만든 소켓과 통신을 하려면 그 소켓을 찾을 수 있어야 하며, 따라서 서버는 소켓번호와 클라이언트가 알고 있을 서버의 IP 주소 및 포트번호(즉, 서버의 소켓주소)를 미리 서로 연결(bind)시켜 두는 것이 필요하기 때문이다.

![image](https://user-images.githubusercontent.com/21019088/54739084-19e73200-4bfa-11e9-8c8b-202f8237095e.png)

연결형 통신(TCP)에서는 listen(), accept()의 호출이 필요하고 비연결형 통신(UDP)에서는 바로 데이터의 송수신이 가능하다.

우선 연결형 서버의 경우에 대해 설명하겠다.

### 4-1-3 listen(), 클라이언트로부터의 연결요청을 기다리기
서버는 클라이언트로부터의 연결요청을 받아들이기 위하여 클라이언트는 기다리고 있어야 하는 상황이 발생한다. 이를 위하여 listen()을 호출한다. 

listen()의 사용문법은 아래와 같다.

![image](https://user-images.githubusercontent.com/21019088/54739173-86623100-4bfa-11e9-81ad-f7396fe96c17.png)

위에서 인자 log는 서버에서 (다음에 설명할) accept()를 처리하는 동안 대기시킬 수 있는 connect()의 요청 수를 지정한다. 즉, 클라이언트가 요구한 연결요청을 최대 log개까지 기다리게 할 수 있다는 것이다.

예를 들어 listen(s, 2);이 코드는 서버가 최대 2개의 connect() 요청을 대기시킬 수 있으며, 세 번째 이후의 connect() 요청은 거절하여 클라이언트가 이 사실을 바로 알 수 있도록 해준다.

한편 listen()은 소켓을 단지 수동 대기모드로 바꾸는 것이다.

### 4-1-4 accept(), 클라이언트로부터의 연결요청 수락

서버가 listen()을 호출한 이후에 어떤 클라이언트에서 connect()로 이 서버에 연결요청을 보내오면 이를 처리하기 위해 서버는 accept()를 호출해 두어야 한다.

accept()의 수행이 성공한 경우에는 접속된 클라이언트와의 일 대 일 통신에 사용할 새로운 소켓이 만들어지고 accept()는 이 소켓번호를 리턴하며 실패시에는 -1을 리턴한다.

accept()는 또한 접속된 클라이언트의 소켓주소 구조체와 구조체의 길이의 포인터를 함수인자 addr과 addrlen으로 각각 알아온다.

accept()의 사용문법은 아래와 같다.

![image](https://user-images.githubusercontent.com/21019088/54739248-d2ad7100-4bfa-11e9-962f-d3f7b30ab9d6.png)

![image](https://user-images.githubusercontent.com/21019088/54739275-de993300-4bfa-11e9-8638-61723b86b161.png)

### 4-1-5 close(), 소켓 종료
소켓을 닫을 때 close()를 호출하는데 데이터그램(UDP) 소켓에서 close()를 호출하면 단순히 사용하던 소켓을 닫는 작업만 수행한다.

그러나 스트림(TCP)소켓은 연결형 서비스이므로 현재 미처리된 패킷들(송신 버퍼에 있으나 아직 송신이 안 된 패킷 또는 현재 송수신중에 있는 패킷)을 모두 처리한 후에 소켓을 닫게 된다.

## ⭐️ fork()
UNIX에서 임의의 프로세스는 fork()를 이용해서 자신과 똑같은 기능을 수행하는 프로세스를 하나 복제할 수 있다.

fork()를 호출한 프로세스를 부모(parent) 프로세스라 하고 새로 생긴 프로세스를 자식(child) 프로세스라고 한다.

자식 프로세스는 부모 프로세스의 코드, 스택, 파일기술자, 소켓번호 등을 공유하게 되어 프로세스 수행 환경이 부모 프로세스와 같게 된다.

단, 새로 생긴 자식 프로세스의 id 번호(PID: Process Identication)는 부모 프로세스의 PID와 구별되며 각종 변수들은 공유하지 않는다.

fork() 시스템 콜이 성공적으로 수행되면 그 순간에 하나의 프로세스가 두 개의 프로세스로 되는데 두 프로세스는 수행할 일을 구분하기 위하여 두 프로세스의 fork() 리턴문이 서로 다르다는 것을 이용한다.

부모 프로세스에게는 fork()의 리턴값으로 새로 만들어진 자식 프로세서의 PID가 리턴되며, 자식 프로세스에게는 fork()의 리턴값이 0이 된다.

한편 fork() 문이 실패한 경우 부모 프로세스에서는 -1을 리턴하고, 자식 프로세스는 생성되지 않는다.

그림 2-14에 PID가 135인 어떤 프로세스가 fork()를 수행하여 자식 프로세스를 만드는 것을 보였다.

![image](https://user-images.githubusercontent.com/21019088/54740296-413ffe00-4bfe-11e9-948c-f3ab1d6b2527.png)

예를들어 아래와 같은 프로그램 코드를 수행하면 fork() 문을 만나는 순간에 두 개의 프로세스가 생성되는데 그 중 자식 프로세스는 fork()의 리턴값이 0이 되므로 child_ work()를 수행하고, 부모 프로세스에서는 fork()의 리턴값이 자식 프로세스의 PID 값(즉 0이 아님)이 되므로 parent_work()를 수행하게 된다.

![image](https://user-images.githubusercontent.com/21019088/54740360-82381280-4bfe-11e9-8b63-697c51717c3a.png)

### refereces
http://jkkang.net/unix/netprg/chap2/net2_intro.html
