## 내부 단편화

![image](https://user-images.githubusercontent.com/21019088/56426540-a1a48700-62f3-11e9-992e-33ccfddd5253.png)

여기 메모리를 보면 빈 공간 50MB가 있다. 그렇게 되면 c작업이 이 메모리에 올라갈 수 있다. 하지만 이 메모리에 올라가게 되면 아래 사진처럼 
20MB라는 비어 있는 공간은 실제로 작업되지는 않으며 유용하게 사용 될 수 없는 공간이 된다. 이것을 내부 단편화라고 한다. 내부 단편화는 메모리에 
30MB 영역만 필요한데 32MB를 할당해서 2MB를 쓸모없게 만드는 것이다. 이 2MB는 너무 작아 쓰기도 애매한 처지가 되는데 이것을 내부 단편화라고 한다.

![image](https://user-images.githubusercontent.com/21019088/56426699-2beceb00-62f4-11e9-96ea-d3d51dabe84b.png)

## 외부 단편화

![image](https://user-images.githubusercontent.com/21019088/56426710-34452600-62f4-11e9-9ae1-144e01d1db64.png)

외부 단편화는 메모리에 남는 공간은 100MB인데 C라는 작업이 70MB일 때 일어나는 경우이다. 메모리에 100MB라는 공간이 있지만 C작업은 
메모리에 들어가지 못한다. 즉 작업보다 많은 공간이 있더라고 실제로 그 작업을 받아들이지 못하는 경우를 외부 단편화라고 한다. 
외부 단편화는 남는 공간은 생각하지 않고 c작업이 쪼개져서 남는 공간에 따로 들어갈 수 있냐 없냐를 묻는 것이다.

## 메모리 단편화 해결 방안

1. 압축 : 메모리 공간들을 재배치해서, 단편화로 인해 분산되어 있는 메모리공간들을 하나로 합치는 기법이다.

2. 통합 : 단편화로 인해 분산된 메모리공간들을 인접해 있는 것끼리 통합시켜 큰 메모리 공간으로 합치는 기법이다. 
압축은 재배치가 일어나지만 통합은 인접한 공간들끼리 통합된다는 차이가 있다.

3. 페이징(가상 메모리 사용, 외부 단편화 해결) : 보조기억장치를 이용한 가상 메모리를 같은 크기의 블록으로 나눈 것을 
페이지라고 한다. 주기억장치를 페이지와 같은 크기로 나눈 것을 프레임이라고 한다. 페이징 기법이란 사용하지 않는 프레임을 
페이지에 옮기고(swap-out), 필요한 메모리를 페이지 단위로 프레임에 옮기는(swap-in)기법이다. 외부 단편화는 해결이 되지만 
내부 단편화는 해결되지 않는다. 페이지와 프레임을 대응시키기 위해 page mapping과정이 필요해서 paging table을 만든다.
연속적으로 저장되지 않아도 된다. 그래서 외부 단편화 문제를 해결 할 수 있다. 페이지 단위를 작게하면 내부 단편화 문제도
해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다.

4. 세그멘테이션(가상 메모리 사용, 내부 단편화 해결) : 페이징기법에서 가상메모리를 같은 크기의 단위로 분할했지만 세그멘테이션기법에서는 
가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환을 하게 된다. 각 세그먼트는 
연속적인 공간에 저장되어 있다. 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다. 
마찬가지로 mapping을 위해 세그먼트 테이블이 필요하다. (각 세그먼트 항목별 세그먼트 시작주소와 세그먼트의 길이 정보를 가지고 있음) 
프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화는 일어나지 않으나 여전히 중간에 프로세스가 메모리를 해제하면 생기는 구멍, 
즉 외부 단편화 문제는 여전히 존재한다.

5. 메모리 풀 : 필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법
메모리 풀 없이 동적할당과 해제를 반복하면 메모리의 랜덤한(실제로는 알고리즘에 의한) 위치에 할당과 해제가 반복되면서 단편화를 일으킬 수 있겠지만 
미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다. 또한 필요한 크기만큼 할당을 해놓기 때문에 
내부 단편화 또한 생기지 않는다. 하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 
사용하지 않아야 한다. 메모리의 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다. 미리 할당해놓고 사용하지 않는 순간에도 계속 할당해놓으므로 
메모리 누수가 있는 방식이다.

## Reference

https://jeong-pro.tistory.com/91
