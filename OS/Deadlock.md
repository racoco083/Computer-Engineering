## Deadlock의 개념

한정된 자원을 여러 프로세스에서 사용하려고 할 때 발생합니다.

* 데드락이 발생할 수 있는 경우

![image](https://user-images.githubusercontent.com/21019088/56457214-4a192080-63b2-11e9-9a7a-56a7d866698a.png)

P1과 P2가 리소스 A, B 둘 다를 얻어야 한다고 가정할 때, t1에 P1이 리소를 A를 얻고 P2가 리소스 B를 얻었다면 
t2때 P1은 리소스 B를, P2는 리소스 A를 기다리게 됩니다. 하지만 서로 원하는 리소스가 상대방에게 할당되어 있기 
때문에 이 두 프로세스는 무한정 기다리게 되는데 이러한 상태을 DeadLock상태라고 합니다.

## Deadlock의 발생 조건

교착 상태는 한 시스템 내에서 다음의 네 가지 조건이 동시에 성립 할 때 발생합니다.
따라서, 아래의 네 가지 조건 중 하나라도 성립하지 않도록 만든다면 교착 상태를 해결할 수 있습니다.

![image](https://user-images.githubusercontent.com/21019088/56457809-07a81180-63bb-11e9-96a0-bcb09d6666ec.png)

## Deadlock 처리

![image](https://user-images.githubusercontent.com/21019088/56457505-b6961e80-63b6-11e9-83ff-3c416128a77a.png)

1. 교착 상태 예방 : 교착 상태 발생 조건 중의 하나를 제거함으로써 해결하는 방법이다.

![image](https://user-images.githubusercontent.com/21019088/56457830-33c39280-63bb-11e9-97a7-6bad789104f2.png)

2. 교착 상태 회피 : 교착 상태가 발생하면 피해나가는 방법이다. 대표적인 알고리즘으로 은행원 알고리즘이 있다.

* 은행원 알고리즘 : 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법이다. 
프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 
검사하여 교착 상태를 회피하는 기법으로 안정 상태에 있으면 자원을 할당하고, 그렇지 않으면 
다른 프로세스들이 자원을 해지할 때까지 대기함.

![image](https://user-images.githubusercontent.com/21019088/56457532-0a086c80-63b7-11e9-9911-8e93933e8a50.png)

3. 교착 상태 탐지  : 자원 할당 그래프를 통해 교착 상태를 탐지할 수 있다.

* 자원 할당 그래프 : 프로세스 Pi로부터 자원 Rj로의 방향 간선은 Pi ->Rj로 표현하며 이것은 프로세스 Pi가 자원을 요청하는 
것으로 현재 이 자원을 기다리는 상태이다. 자원 Rj로부터 프로세스 Pi로의 방향 간선은 Rj->Pi로 표현하며 이것은 자원을 프로세스 
Pi에 할당된 것을 의미 한다. 자원을 요청할 때마다 탐지 알고리즘을 실행하여 오버헤드가 발생한다.

![image](https://user-images.githubusercontent.com/21019088/56457665-22798680-63b9-11e9-9f83-0201d51964f9.png)

자원 할당 그래프에서 사이클이 생기면 곧 데드락이란 것을 알 수 있다.

4. 교착 상태로부터 회복 : 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 회복하는 것을 의미한다.

* 프로세스를 종료하는 방법

    (1) 교착 상태의 프로세스를 모두 중지

    (2) 교착 상태가 제거될 때까지 한 프로세스씩 중지

* 자원을 선점하는 방법

    (1) 교착 상태의 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며, 
    해당 프로세스를 일시 정지 시키는 방법
    
    (2) 우선순위가 낮은 프로세스, 수행된 횟수가 적은 프로세스 등을 위주로 프로세스의 자원을 선점한다.
    
## Deadlock과 Starvation 비교

![image](https://user-images.githubusercontent.com/21019088/56458145-03c9be80-63be-11e9-8d04-12c8c9ba976a.png)

데드락은 자원이 두 개(자원이 하나일 때는 발생하지 않는다.)이고 프로세스가 2개 이상일 때 발생하는 것이고, starvation은 자원이 하나고 프로세스가 2개 이상일 때 발생한다. 즉, 시스템 부하가 많아서 낮은 등급에 있는 준비 큐에 있는 프로세스가 무한정 기다리는 현상이다. 그래서 이걸 해결하기 위하여 aging기법이 있는데 자원을 오랫동안 못 쓴 프로세스의 우선순위를 높여 자원을 현재 점유하고 있는 프로세스보다 우선순위를 높여 자원을 가로채게 하는 것이다.

